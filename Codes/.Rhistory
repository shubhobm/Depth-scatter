}
ones = function(m,n){
matrix(1, nrow=m, ncol=n)
}
## function to calculate weighted projection quantile depth
EPQD1 = function(X, grid, nu=1e3){
p = ncol(X)
b = apply(X, 2, median)
X0 = X - ones(nrow(X),1) %*% b
grid0 = grid - ones(nrow(grid),1) %*% b
## get matrix of weighted PQDs for all points
npt = dim(grid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = as.matrix(rnorm(p)); u = u/sqrt(sum(u^2))
uecdf = ecdf(X0%*%u)
Fuxu.mat[,iu] = uecdf(grid0%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
return(cbind(grid,EPQD.vec))
}
wEPQD1 = function(X, grid, sig, nu=1e3){
p = ncol(X)
b = apply(X, 2, median)
X0 = X - ones(nrow(X),1) %*% b
grid0 = grid - ones(nrow(grid),1) %*% b
## get matrix of weighted PQDs for all points
npt = dim(grid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = as.matrix(rnorm(p)); u = u/sqrt(sum(u^2))
I.minus.Pu = diag(p) - u%*%t(u)
Xuperp = X0 %*% I.minus.Pu
scaled.perp = sqrt(Xuperp^2 %*% ones(ncol(X),1))
#w = ifelse(scaled.perp>sig, 0, 1)
#w = sig*exp(-scaled.perp/sig)
w = dnorm(scaled.perp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w * (X0%*%u))
gridperp = grid0 %*% I.minus.Pu
scaled.gridperp = sqrt(gridperp^2 %*% ones(ncol(X),1))
#wu = ifelse(scaled.gridperp>sig, 0, 1)
#wu = sig*exp(-scaled.gridperp/sig)
wu = dnorm(scaled.gridperp, sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu * (grid0%*%u))
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
return(cbind(grid,EPQD.vec))
}
pcarank = function(X, ...){
X = as.matrix(X)
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1 * (1/d1[,3]-1)
princomp(Xrank, ...)
}
pcarank1D = function(X, ...){
X1 = apply(X,2,rank)
princomp(X1, ...)
}
d=EPQD1(x,x)
sd = s*(max(d[,3])-d[,3])
cov(sd)
cov(s)/cov(sd)
s11=s1/5
s12=s2
norm1 = sqrt(s11^2+s12^2)
s01 = cbind(s11/norm1, s12/norm1)
cov(s01)
var(norm1/norm)
plot(s01)
diag(c(5,1)) %*% cov(s01)
diag(c(5,1)) %*% cov(s01)/3
cov(s)
cov(s01*norm1/norm)
cov(s01*(ones(1,2)%*%norm1/norm))
cov(s01*(ones(2,1)%*%(norm1/norm)))
n = ones(2,1)%*%(norm1/norm)
head(n)
cov(s01*((norm1/norm) %*% ones(1,2)))
n = (norm1/norm) %*% ones(1,2)
head(n)
cov(s01*n)
cov(s01)
cov(s1)
cov(s)
apply(s01*n, 1, mean)
apply(s01*n, 2, mean)
apply(s01/n, 2, mean)
diag(25,1) %*% var(s01*n)
diag(25,1) %*% cov(s01*n)
cov(s01*n)
diag(c(25,1)) %*% cov(s01*n)
diag(c(25,1)) %*% cov(s01) * var(n)
head(n)
var(n[,1])
var(n)
?cov
cov(s01, norm1/norm)
cov(s01, norm/norm1)
var(s01)
var(s01*n)
head(n)
cov(s01,n)
diag(c(25,1)) %*% var(s01*n)
var(s01) * var(n)
a = matrix(rnorm(2e3), ncol=2)
b=rnorm(1e3)
cov(a,b)
cov(a*b)
cov(a)*var(b)
cov(s01*n)
cov(s01)*var(n)
cov(s01)*cov(n)
cov(a)
var(b)
b1=ones(1,2) %*% b
b1=ones(,) %*% b
b1=ones(2,1) %*% b
head(b1)
b1=t(ones(2,1) %*% b)
head(b1)
cov(a*b1)
cov(a) * cov(b1)
cov(b1)
cov(s01*n)
mean(s01[,1])
var(s01[,1])
var(s01[,1]*n[,1])
mean((s01[,1]*n[,1])^2)
var(s01[,1] * mean(n[,1]^2))
var(s01[,1]) * mean(n[,1]^2)
var(s01[,1])
mean(s01[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1])*mean(n[,1]))^2
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1]*n[,1]))^2
var(s01[,1] * n[,1])
mean(s01[,1]^2 * n[,1]^2) - (mean(s01[,1]*n[,1]))^2
mean(s01[,1]^2 * n[,1]^2)
mean(s01[,1]^2)
mean(n[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(s01[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(n[,1]^2)
cov(s01,n[,1])
cov(sd)
cov(s)/cov(sd)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
cov(X)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=2*sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
a=rchisq(1000,1)
b=rchisq(1000,1)
cov(a/(a+b),b/(a+b))
corr(a/(a+b),b/(a+b))
cor(a/(a+b),b/(a+b))
c=rchisq(1000,1)
s=a+b+c
cor(a/s,b/s)
cor(a/s,b/s,c/s)
cov(cbind(a/s,b/s,c/s))
cor(cbind(a/s,b/s,c/s))
install.packages("fastM")
require(fastM)
TYLERshape(matrix(rnorm(100),ncol=2))
X = matrix(rnorm(1e3), ncol=2)
cov(X)
TYLERshape(X)
X[91:100,] = X[91:100,] + 50
cov(X)
TYLERshape(X)
?TYLERshape
## Sim_influenceplot: Plots to compare influence functions for DCM and SCM
setwd("C:/Study/My projects/Depth-scatter/Codes")
rm(list=ls());
source('misc_functions.R')
library(parallel)
library(doSNOW)
## Functions
## setup 1: Sigma = diag(2,1)
set.seed(02052015)
lam = c(2,1)
Sig = diag(lam)
Z = matrix(rnorm(1e3),ncol=2)
X = Z %*% sqrt(Sig)
# make grid of points
pts = seq(-2, 2, by=.1)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# Sample covariance matrix
r = sqrt(rowSums(xygrid^2))
Ugrid = xygrid / r
IFnorm.S = r^2*abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
persp(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45)
library("plot3D", lib.loc="C:/Study/R/R-3.1.1/library")
?persp3D
persp3D(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45)
persp3D(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)",
theta=45, phi=45)
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45)
IFnorm.tyler = 4*sqrt(abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2])))
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45)
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,colvar=NA)
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,colvar=F)
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,colvar=F,border='black')
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,colvar=F,border=gray(.7))
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,colvar=F,border=gray(.2))
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,colvar=NULL,border=gray(.2))
persp3D(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,colvar=gray(.1),border=gray(.2))
?persp
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,col=gray(.1),border=gray(.2))
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,col=gray(.9),border=gray(.2))
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45,col=gray(.9),border=gray(.3))
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45,col=gray(.9),border=gray(.3))
lam.Zsq = (Z * Z) %*% Sig
sum.lam.Zsq = rowSums(lam.Zsq)
lamS = colMeans(lam.Zsq / sum.lam.Zsq)
# get norms of influence fns for eigenvectors
multS = sqrt(lam[1]*lam[2])/(lamS[1] - lamS[2])
IFnorm.S = sqrt(abs(multS * Ugrid[,1] * Ugrid[,2]))
# plot result
persp(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45)
persp(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
DZ = EPQD(Z, Z)[,3]
DZ = max(Z) - Z
lamDS = colMeans((DZ^2/sum.lam.Zsq) * lam.Zsq)
# get htped at grid points
Dgrid = EPQD(X, xygrid)[,3]
Dgrid = max(Dgrid) - Dgrid
# get norms of influence fns for eigenvectors
mult = sqrt(lam[1]*lam[2])/(lamDS[1] - lamDS[2])
IFnorm.D = sqrt(abs(mult * xygrid[,1] * xygrid[,2] * Dgrid^2 / diag(xygrid %*% Sig %*% t(xygrid))))
# plot result
persp(pts, pts, matrix(IFnorm.D, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed",
theta=45, phi=45)
persp(pts, pts, matrix(IFnorm.DS, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
persp(pts, pts, matrix(IFnorm.D, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
multS = sqrt(lam[1]*lam[2])/(lamS[1] - lamS[2])
IFnorm.S = sqrt(abs(multS * Ugrid[,1] * Ugrid[,2]))
# plot result
persp(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
# Influence fn plot for Tyler's scatter matrix
IFnorm.tyler = 4*abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45,col=gray(.9),border=gray(.3))
IFnorm.tyler = 4*abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45,col=gray(.9),border=gray(.3))
DZ = EPQD(Z, Z)[,3]
DZ = max(Z) - Z
lamDS = colMeans((DZ^2/sum.lam.Zsq) * lam.Zsq)
# get htped at grid points
Dgrid = EPQD(X, xygrid)[,3]
Dgrid = max(Dgrid) - Dgrid
# get norms of influence fns for eigenvectors
mult = sqrt(lam[1]*lam[2])/(lamDS[1] - lamDS[2])
IFnorm.D = abs(mult * xygrid[,1] * xygrid[,2] * Dgrid^2 / diag(xygrid %*% Sig %*% t(xygrid)))
# plot result
persp(pts, pts, matrix(IFnorm.D, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
r = sqrt(rowSums(xygrid^2))
Ugrid = xygrid / r
IFnorm = abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
IFnorm.Sig = r^2*IFnorm
persp3D(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)",
theta=45, phi=45)
persp(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
par(mfrow=c(2,2))
# Sample covariance matrix
r = sqrt(rowSums(xygrid^2))
Ugrid = xygrid / r
IFnorm = abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
IFnorm.Sig = r^2*IFnorm
persp(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
# Influence fn plot for SCM
# get eigenvalues of SCM
lam.Zsq = (Z * Z) %*% Sig
sum.lam.Zsq = rowSums(lam.Zsq)
lamS = colMeans(lam.Zsq / sum.lam.Zsq)
# get norms of influence fns for eigenvectors
multS = sqrt(lam[1]*lam[2])/(lamS[1] - lamS[2])
IFnorm.S = sqrt(abs(multS * Ugrid[,1] * Ugrid[,2]))
# plot result
persp(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
# Influence fn plot for Tyler's scatter matrix
IFnorm.tyler = 4*IFnorm
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45,col=gray(.9),border=gray(.3))
# Influence fn plot for DCM
# get eigenvalues of DCM
DZ = EPQD(Z, Z)[,3]
DZ = max(Z) - Z
lamDS = colMeans((DZ^2/sum.lam.Zsq) * lam.Zsq)
# get htped at grid points
Dgrid = EPQD(X, xygrid)[,3]
Dgrid = max(Dgrid) - Dgrid
# get norms of influence fns for eigenvectors
mult = sqrt(lam[1]*lam[2])/(lamDS[1] - lamDS[2])
IFnorm.D = abs(mult * xygrid[,1] * xygrid[,2] * Dgrid^2 / diag(xygrid %*% Sig %*% t(xygrid)))
# plot result
persp(pts, pts, matrix(IFnorm.D, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
par(mfrow=c(1,1))
par()
par(mfrow=c(2,2), oma=c(1,1,1,1))
persp(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
par(mfrow=c(2,2), oma=c(-1,-1,-1,-1))
# Sample covariance matrix
r = sqrt(rowSums(xygrid^2))
Ugrid = xygrid / r
IFnorm = abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
IFnorm.Sig = r^2*IFnorm
persp(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
?par
par(mfrow=c(2,2), mai=c(-1,-1,-1,-1))
par(mfrow=c(2,2), mai=rep(0,4))
persp(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
default = par()
par(mfrow=c(2,2), mai=rep(0,4))
# Sample covariance matrix
r = sqrt(rowSums(xygrid^2))
Ugrid = xygrid / r
IFnorm = abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
IFnorm.Sig = r^2*IFnorm
persp(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
# Influence fn plot for SCM
# get eigenvalues of SCM
lam.Zsq = (Z * Z) %*% Sig
sum.lam.Zsq = rowSums(lam.Zsq)
lamS = colMeans(lam.Zsq / sum.lam.Zsq)
# get norms of influence fns for eigenvectors
multS = sqrt(lam[1]*lam[2])/(lamS[1] - lamS[2])
IFnorm.S = sqrt(abs(multS * Ugrid[,1] * Ugrid[,2]))
# plot result
persp(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
# Influence fn plot for Tyler's scatter matrix
IFnorm.tyler = 4*IFnorm
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45,col=gray(.9),border=gray(.3))
# Influence fn plot for DCM
# get eigenvalues of DCM
DZ = EPQD(Z, Z)[,3]
DZ = max(Z) - Z
lamDS = colMeans((DZ^2/sum.lam.Zsq) * lam.Zsq)
# get htped at grid points
Dgrid = EPQD(X, xygrid)[,3]
Dgrid = max(Dgrid) - Dgrid
# get norms of influence fns for eigenvectors
mult = sqrt(lam[1]*lam[2])/(lamDS[1] - lamDS[2])
IFnorm.D = abs(mult * xygrid[,1] * xygrid[,2] * Dgrid^2 / diag(xygrid %*% Sig %*% t(xygrid)))
# plot result
persp(pts, pts, matrix(IFnorm.D, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
par(default)
par()$mai
default = par()
par(mfrow=c(2,2), mai=rep(.5,4))
# Sample covariance matrix
r = sqrt(rowSums(xygrid^2))
Ugrid = xygrid / r
IFnorm = abs(Ugrid[,1] * Ugrid[,2] * sqrt(lam[1]*lam[2])/(lam[1] - lam[2]))
IFnorm.Sig = r^2*IFnorm
persp(pts, pts, matrix(IFnorm.Sig, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
# Influence fn plot for SCM
# get eigenvalues of SCM
lam.Zsq = (Z * Z) %*% Sig
sum.lam.Zsq = rowSums(lam.Zsq)
lamS = colMeans(lam.Zsq / sum.lam.Zsq)
# get norms of influence fns for eigenvectors
multS = sqrt(lam[1]*lam[2])/(lamS[1] - lamS[2])
IFnorm.S = sqrt(abs(multS * Ugrid[,1] * Ugrid[,2]))
# plot result
persp(pts, pts, matrix(IFnorm.S, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
# Influence fn plot for Tyler's scatter matrix
IFnorm.tyler = 4*IFnorm
persp(pts, pts, matrix(IFnorm.tyler, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45,col=gray(.9),border=gray(.3))
# Influence fn plot for DCM
# get eigenvalues of DCM
DZ = EPQD(Z, Z)[,3]
DZ = max(Z) - Z
lamDS = colMeans((DZ^2/sum.lam.Zsq) * lam.Zsq)
# get htped at grid points
Dgrid = EPQD(X, xygrid)[,3]
Dgrid = max(Dgrid) - Dgrid
# get norms of influence fns for eigenvectors
mult = sqrt(lam[1]*lam[2])/(lamDS[1] - lamDS[2])
IFnorm.D = abs(mult * xygrid[,1] * xygrid[,2] * Dgrid^2 / diag(xygrid %*% Sig %*% t(xygrid)))
# plot result
persp(pts, pts, matrix(IFnorm.D, nrow=lengrid, byrow=T),
xlab="x1", ylab="x2", zlab="IF(x0)", ticktype="detailed", nticks=3,
theta=45, phi=45, col=gray(.9), border=gray(.3))
par(default)
