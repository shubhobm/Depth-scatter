gridperp = grid0 %*% I.minus.Pu
scaled.gridperp = sqrt(gridperp^2 %*% ones(ncol(X),1))
#wu = ifelse(scaled.gridperp>sig, 0, 1)
#wu = sig*exp(-scaled.gridperp/sig)
wu = dnorm(scaled.gridperp, sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu * (grid0%*%u))
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
return(cbind(grid,EPQD.vec))
}
pcarank = function(X, ...){
X = as.matrix(X)
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1 * (1/d1[,3]-1)
princomp(Xrank, ...)
}
pcarank1D = function(X, ...){
X1 = apply(X,2,rank)
princomp(X1, ...)
}
d=EPQD1(x,x)
sd = s*(max(d[,3])-d[,3])
cov(sd)
cov(s)/cov(sd)
s11=s1/5
s12=s2
norm1 = sqrt(s11^2+s12^2)
s01 = cbind(s11/norm1, s12/norm1)
cov(s01)
var(norm1/norm)
plot(s01)
diag(c(5,1)) %*% cov(s01)
diag(c(5,1)) %*% cov(s01)/3
cov(s)
cov(s01*norm1/norm)
cov(s01*(ones(1,2)%*%norm1/norm))
cov(s01*(ones(2,1)%*%(norm1/norm)))
n = ones(2,1)%*%(norm1/norm)
head(n)
cov(s01*((norm1/norm) %*% ones(1,2)))
n = (norm1/norm) %*% ones(1,2)
head(n)
cov(s01*n)
cov(s01)
cov(s1)
cov(s)
apply(s01*n, 1, mean)
apply(s01*n, 2, mean)
apply(s01/n, 2, mean)
diag(25,1) %*% var(s01*n)
diag(25,1) %*% cov(s01*n)
cov(s01*n)
diag(c(25,1)) %*% cov(s01*n)
diag(c(25,1)) %*% cov(s01) * var(n)
head(n)
var(n[,1])
var(n)
?cov
cov(s01, norm1/norm)
cov(s01, norm/norm1)
var(s01)
var(s01*n)
head(n)
cov(s01,n)
diag(c(25,1)) %*% var(s01*n)
var(s01) * var(n)
a = matrix(rnorm(2e3), ncol=2)
b=rnorm(1e3)
cov(a,b)
cov(a*b)
cov(a)*var(b)
cov(s01*n)
cov(s01)*var(n)
cov(s01)*cov(n)
cov(a)
var(b)
b1=ones(1,2) %*% b
b1=ones(,) %*% b
b1=ones(2,1) %*% b
head(b1)
b1=t(ones(2,1) %*% b)
head(b1)
cov(a*b1)
cov(a) * cov(b1)
cov(b1)
cov(s01*n)
mean(s01[,1])
var(s01[,1])
var(s01[,1]*n[,1])
mean((s01[,1]*n[,1])^2)
var(s01[,1] * mean(n[,1]^2))
var(s01[,1]) * mean(n[,1]^2)
var(s01[,1])
mean(s01[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1])*mean(n[,1]))^2
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1]*n[,1]))^2
var(s01[,1] * n[,1])
mean(s01[,1]^2 * n[,1]^2) - (mean(s01[,1]*n[,1]))^2
mean(s01[,1]^2 * n[,1]^2)
mean(s01[,1]^2)
mean(n[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(s01[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(n[,1]^2)
cov(s01,n[,1])
cov(sd)
cov(s)/cov(sd)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
cov(X)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=2*sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
a=rchisq(1000,1)
b=rchisq(1000,1)
cov(a/(a+b),b/(a+b))
corr(a/(a+b),b/(a+b))
cor(a/(a+b),b/(a+b))
c=rchisq(1000,1)
s=a+b+c
cor(a/s,b/s)
cor(a/s,b/s,c/s)
cov(cbind(a/s,b/s,c/s))
cor(cbind(a/s,b/s,c/s))
install.packages("fastM")
require(fastM)
TYLERshape(matrix(rnorm(100),ncol=2))
X = matrix(rnorm(1e3), ncol=2)
cov(X)
TYLERshape(X)
X[91:100,] = X[91:100,] + 50
cov(X)
TYLERshape(X)
?TYLERshape
Sys.info()[4]
acos(NA)
acos(NaN)
X=MATRIC(0,2,2)
x=matrix(0,2,2)
x[,2]
class(x[,2])
pbp.2014 <- read.csv("C:/Study/My projects/Depth-scatter/Data/pbp-2014.csv")
View(pbp.2014)
nfl2014stats <- read.csv("C:/Study/My projects/Depth-scatter/Data/nfl2014stats.csv")
View(nfl2014stats)
nfl2013stats <- read.csv("C:/Study/My projects/Depth-scatter/Data/nfl2013stats.csv")
View(nfl2013stats)
plot(nfl2013stats[,5:8])
nfl2013lines <- read.csv("C:/Study/My projects/Depth-scatter/Data/nfl2013lines.csv")
View(nfl2013lines)
players_2013.12.12 <- read.csv("C:/Study/My projects/Depth-scatter/Data/players_2013-12-12.csv")
View(players_2013.12.12)
citation()
?screeplot
## Analyze_octane: analysis of octane data
rm(list=ls())
setwd("C:/Study/My projects/Depth-scatter/Codes")
source('misc_functions.R')
## Octane data
require(ellipse)
require(ChemoSpec)
require(rrcov)
screeplot(PcaRank(data.X))
Octane <- read.csv("../Data/Octane.csv")
Octane.X = Octane[,-c(1,2)]
n = nrow(Octane.X)
p = ncol(Octane.X)
screeplot(PcaRank(data.X))
screeplot(PcaRank(Octane.X))
require(fda.usc)
screeplot(PcaRank(Octane.X))
screeplot(PcaClassic(Octane.X))
pcamod = PcaClassic(Octane.X)
prop10 = pcamod@eigenvalues / sum(pcamod@eigenvalues)
pcarank = PcaRank(Octane.X)
prop10.r = pcarank@eigenvalues / sum(pcarank@eigenvalues)
par(mfrow=c(1,2))
barplot(prop10[1:10])
barplot(prop10.r[1:10])
par(mfrow=c(1,1))
prop10
prop10.r
plot(prop10[1:10], type='b')
lines(prop10.r[1:10], type='b')
lines(prop10.r[1:10], type='b', col="blue")
?pch
par(mfrow=c(1,2))
plot(prop10[1:10], type='b')
lines(prop10.r[1:10], type='b', col="blue", pch=0, lty=2)
par(mfrow=c(1,1))
plot(prop10[1:10], type='b')
lines(prop10.r[1:10], type='b', col="blue", pch=0, lty=2)
plot(prop10[1:10], type='b', col="red")
lines(prop10.r[1:10], type='b', col="blue", pch=0, lty=2)
par(mfrow=c(1,2))
plot(prop10[1:10], type='b', col="red", lwd=2,
xlab="index of PC", ylab="proportion of variance explained")
lines(prop10.r[1:10], type='b', lwd=2, col="blue", pch=0, lty=2)
par(mfrow=c(1,1))
plot(prop10[1:10], type='b', col="red", lwd=2,
xlab="index of PC", ylab="proportion of variance explained")
lines(prop10.r[1:10], type='b', lwd=2, col="blue", pch=0, lty=2)
legend(topright, c("Classical PCA", "Depth PCA"), lwd=2, col=c("red","blue"), lty=c(1,2))
legend('topright', c("Classical PCA", "Depth PCA"), lwd=2, col=c("red","blue"), lty=c(1,2))
plot(prop10[1:10], type='b', col="red", lwd=2,
xlab="index of PC", ylab="proportion of variance explained")
lines(prop10.r[1:10], type='b', lwd=2, col="blue", pch=0, lty=2)
legend('topright', c("Classical PCA", "Depth PCA"), lwd=2, col=c("red","blue"), lty=c(1,2))
## Analyze_octane: analysis of octane data
rm(list=ls())
setwd("C:/Study/My projects/Depth-scatter/Codes")
source('misc_functions.R')
## Octane data
require(ellipse)
require(ChemoSpec)
require(rrcov)
require(fda.usc)
Octane <- read.csv("../Data/Octane.csv")
Octane.X = Octane[,-c(1,2)]
n = nrow(Octane.X)
p = ncol(Octane.X)
distanceplot = function(data.X, npc, ...){
# vanila PCA
pcamod = PcaClassic(Octane.X, k=2)
sd = pcamod@sd
od = pcamod@od
csd = pcamod@cutoff.sd
cod = pcamod@cutoff.od
indices = 1:n
which.ind = which(sd > csd | od > cod)
## distance-distance plots
par(mfrow=c(1,2))
plot(sd, od,
main="Classical PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csd, col="red")
abline(h=cod, col="red")
if(length(which.ind>0)){
text(sd[which.ind], od[which.ind], indices[which.ind], pos=1, cex=.7)
}
# rank PCA
pcarank = PcaRank(Octane.X, k=2)
sdrank = pcarank@sd
odrank = pcarank@od
csdrank = pcarank@cutoff.sd
codrank = pcarank@cutoff.od
indices = 1:n
which.ind = which(sdrank > csdrank | odrank > codrank)
## distance-distance plots
plot(sdrank, odrank,
main="Depth PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csdrank, col="red")
abline(h=codrank, col="red")
if(length(which.ind>0)){
text(sdrank[which.ind], odrank[which.ind], indices[which.ind], pos=1, cex=.7)
}
par(mfrow=c(1,1))
}
distanceplot(Octane.X, 2, xlim=c(0,10), ylim=c(0,1.3), pch=19, col="blue")
distanceplot = function(data.X, npc, ...){
# vanila PCA
pcamod = PcaClassic(Octane.X, k=3)
sd = pcamod@sd
od = pcamod@od
csd = pcamod@cutoff.sd
cod = pcamod@cutoff.od
indices = 1:n
which.ind = which(sd > csd | od > cod)
## distance-distance plots
par(mfrow=c(1,2))
plot(sd, od,
main="Classical PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csd, col="red")
abline(h=cod, col="red")
if(length(which.ind>0)){
text(sd[which.ind], od[which.ind], indices[which.ind], pos=1, cex=.7)
}
# rank PCA
pcarank = PcaRank(Octane.X, k=3)
sdrank = pcarank@sd
odrank = pcarank@od
csdrank = pcarank@cutoff.sd
codrank = pcarank@cutoff.od
indices = 1:n
which.ind = which(sdrank > csdrank | odrank > codrank)
## distance-distance plots
plot(sdrank, odrank,
main="Depth PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csdrank, col="red")
abline(h=codrank, col="red")
if(length(which.ind>0)){
text(sdrank[which.ind], odrank[which.ind], indices[which.ind], pos=1, cex=.7)
}
par(mfrow=c(1,1))
}
distanceplot(Octane.X, 2, xlim=c(0,10), ylim=c(0,1.3), pch=19, col="blue")
distanceplot = function(data.X, npc, ...){
# vanila PCA
pcamod = PcaClassic(Octane.X, k=7)
sd = pcamod@sd
od = pcamod@od
csd = pcamod@cutoff.sd
cod = pcamod@cutoff.od
indices = 1:n
which.ind = which(sd > csd | od > cod)
## distance-distance plots
par(mfrow=c(1,2))
plot(sd, od,
main="Classical PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csd, col="red")
abline(h=cod, col="red")
if(length(which.ind>0)){
text(sd[which.ind], od[which.ind], indices[which.ind], pos=1, cex=.7)
}
# rank PCA
pcarank = PcaRank(Octane.X, k=7)
sdrank = pcarank@sd
odrank = pcarank@od
csdrank = pcarank@cutoff.sd
codrank = pcarank@cutoff.od
indices = 1:n
which.ind = which(sdrank > csdrank | odrank > codrank)
## distance-distance plots
plot(sdrank, odrank,
main="Depth PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csdrank, col="red")
abline(h=codrank, col="red")
if(length(which.ind>0)){
text(sdrank[which.ind], odrank[which.ind], indices[which.ind], pos=1, cex=.7)
}
par(mfrow=c(1,1))
}
distanceplot(Octane.X, 2, xlim=c(0,10), ylim=c(0,1.3), pch=19, col="blue")
plot(PcaClassic(Octane.X, k=2))
plot(PcaClassic(Octane.X, k=7))
plot(PcaHubert(Octane.X, k=7))
plot(PcaRank(Octane.X, k=7))
plot(PcaRank(Octane.X, k=2))
plot(PcaClassic(Octane.X, k=2))
distanceplot = function(data.X, npc, ...){
# vanila PCA
pcamod = PcaClassic(Octane.X, k=2)
sd = pcamod@sd
od = pcamod@od
csd = pcamod@cutoff.sd
cod = pcamod@cutoff.od
indices = 1:n
which.ind = which(sd > csd | od > cod)
## distance-distance plots
par(mfrow=c(1,2))
plot(sd, od,
main="Classical PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csd, col="red")
abline(h=cod, col="red")
if(length(which.ind>0)){
text(sd[which.ind], od[which.ind], indices[which.ind], pos=1, cex=.7)
}
# rank PCA
pcarank = PcaRank(Octane.X, k=2)
sdrank = pcarank@sd
odrank = pcarank@od
csdrank = pcarank@cutoff.sd
codrank = pcarank@cutoff.od
indices = 1:n
which.ind = which(sdrank > csdrank | odrank > codrank)
## distance-distance plots
plot(sdrank, odrank,
main="Depth PCA", xlab="Score distance", ylab="Orthogonal distance", ...)
abline(v=csdrank, col="red")
abline(h=codrank, col="red")
if(length(which.ind>0)){
text(sdrank[which.ind], odrank[which.ind], indices[which.ind], pos=1, cex=.7)
}
par(mfrow=c(1,1))
}
distanceplot(Octane.X, 2, xlim=c(0,10), ylim=c(0,1.3), pch=19, col="blue")
pca3 <- PcaClassic(bus2, k=3)               # classical
rpca3 <- PcaLocantore(bus2, k=3)            # spherical (Locantore, 1999)
hpca3 <- PcaHubert(bus2, k=3)               # Hubert
mpca3 = PcaCov(bus2, cov.control=CovControlMcd(), k=3) # MCD
dpca3 = PcaRank(bus2, k=3)                  # Depth
dist <- pca3@od^2
rdist <- rpca3@od^2
hdist <- hpca3@od^2
mdist = mpca3@od^2
ddist = dpca3@od^2
## calculate the quantiles of the distances to the 3-dimensional hyperplane
qclass  <- round(quantile(dist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qspc <- round(quantile(rdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qhubert <- round(quantile(hdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qmcd <- round(quantile(mdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qdepth <- round(quantile(ddist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qq <- cbind(rbind(qclass, qspc, qhubert, qmcd, qdepth),
round(c(max(dist), max(rdist), max(hdist), max(mdist), max(ddist)), 0))
colnames(qq)[10] <- "Max"
rownames(qq) <- c("Classical", "Spherical", "Hubert", "MCD", "Depth")
cat("\nBus data: quantiles of distances to hyperplane\n")
print(qq)
## Analyze_octane: analysis of octane data
rm(list=ls())
setwd("C:/Study/My projects/Depth-scatter/Codes")
source('misc_functions.R')
## Octane data
library(ellipse)
library(rrcov)
library(fda.usc)
## Analyze bus data
data(bus)
bus1 <- bus[, -9]
madbus <- apply(bus1, 2, mad)
bus2 <- sweep(bus1, 2, madbus, "/", check.margin = FALSE)
# bus2 = scale(bus2)
pca <- PcaClassic(bus2)
rpca <- PcaLocantore(bus2)
pcaHubert <- PcaHubert(bus2, k=17, kmax=17, mcd=FALSE)
pcamcd <- PcaCov(bus2, cov.control=CovControlMcd())
#pcaogk <- PcaCov(bus2, cov.control=CovControlOgk())
pcarank = PcaRank(bus2)
ev <- getEigenvalues(pca)
evrob <- getEigenvalues(rpca)
evhub <- getEigenvalues(pcaHubert)
evmcd <- getEigenvalues(pcamcd)
#evogk <- getEigenvalues(pcaogk)
evrank = getEigenvalues(pcarank)
uvar <- matrix(nrow=6, ncol=6)
svar <- sum(ev)
svarrob <- sum(evrob)
svarhub <- sum(evhub)
svarmcd <- sum(evmcd)
svarogk <- sum(evogk)
svarrank = sum(evrank)
for(i in 1:6){
uvar[i,1] <- i
uvar[i,2] <- round((svar - sum(ev[1:i]))/svar, 3)
uvar[i,3] <- round((svarrob - sum(evrob[1:i]))/svarrob, 3)
uvar[i,4] <- round((svarhub - sum(evhub[1:i]))/svarhub, 3)
uvar[i,5] <- round((svarmcd - sum(evmcd[1:i]))/svarmcd, 3)
#  uvar[i,6] <- round((svarogk - sum(evogk[1:i]))/svarogk, 3)
uvar[i,6] <- round((svarrank - sum(evrank[1:i]))/svarrank, 3)
}
uvar <- as.data.frame(uvar)
names(uvar) <- c("q", "Classical","Spherical", "Hubert", "MCD", "Depth")
cat("\nBus data: proportion of unexplained variability for q components\n")
print(uvar)
## Reproduce Table 6.4 from Maronna et al. (2006), page 214, adding DCM
##
## Compute classical and robust PCA extracting only the first 3 components
## and take the squared orthogonal distances to the 3-dimensional hyperplane
##
pca3 <- PcaClassic(bus2, k=3)               # classical
rpca3 <- PcaLocantore(bus2, k=3)            # spherical (Locantore, 1999)
hpca3 <- PcaHubert(bus2, k=3)               # Hubert
mpca3 = PcaCov(bus2, cov.control=CovControlMcd(), k=3) # MCD
dpca3 = PcaRank(bus2, k=3)                  # Depth
dist <- pca3@od^2
rdist <- rpca3@od^2
hdist <- hpca3@od^2
mdist = mpca3@od^2
ddist = dpca3@od^2
## calculate the quantiles of the distances to the 3-dimensional hyperplane
qclass  <- round(quantile(dist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qspc <- round(quantile(rdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qhubert <- round(quantile(hdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qmcd <- round(quantile(mdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qdepth <- round(quantile(ddist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
qq <- cbind(rbind(qclass, qspc, qhubert, qmcd, qdepth),
round(c(max(dist), max(rdist), max(hdist), max(mdist), max(ddist)), 0))
colnames(qq)[10] <- "Max"
rownames(qq) <- c("Classical", "Spherical", "Hubert", "MCD", "Depth")
cat("\nBus data: quantiles of distances to hyperplane\n")
print(qq)
