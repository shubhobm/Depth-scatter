for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
(p.rank = princomp(Xrank)); p.rank$loadings
(p.rank$sdev[1]/p.rank$sdev[2])^2
Xrank = X1 * (max(d1[,3]) - d1[,3])
(p.rank = princomp(Xrank)); p.rank$loadings
(p.rank$sdev[1]/p.rank$sdev[2])^2
(p.rank$sdev[1]/p.rank$sdev[2])
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
(p.rank = princomp(Xrank)); p.rank$loadings
(p.rank$sdev[1]/p.rank$sdev[2])
a=rchisq(1e3,1)
b=rchisq(1e3,1)
mean(a)
mean(b)
d=25*a+b
d
mean(a/d)
mean(b/d)
mean(a)
mean(b)
mean(25*a/d)
plot(b)
hist(b)
plot(density(b))
d1=a+b
mean(a/d1)
mean(b/d1)
d2=d1/d
mean(d1)
mean(d2)
mean(b/d1*d2)
mean(b/d)
mean(25*a/d1*d2)
mean(25*a/d)
mean(25*a/d1)*mean(d2)
mean(b/d1)*mean(d2)
s1=5*rnorm(1e3)
s1=rnorm(1e3)
s1=5*rnorm(1e3)
s2=rnorm(1e3)
norm=s1^2+s2^2
s=cbind(s1/norm, s2/norm)
cov(s)
cov(cbind(s1,s2))
apply(s, 2, function(x) sqrt(sum(x^2)))
apply(s, 1, function(x) sqrt(sum(x^2)))
s[1,]
s1[1]
s2[1]
norm=sqrt(s1^2+s2^2)
s=cbind(s1/norm, s2/norm)
cov(s)
x=cbind(s1, s2)
cov(x)
cor(x)
cor(s)
my.mvrnorm = function(n, mu, Sigma){
p = length(mu)
# compute square root of covariance matrix
eo=eigen(Sigma, symmetric=TRUE)
sigma.sqrt=eo$vec%*%diag(eo$val^0.5)%*%t(eo$vec)
# generate random normals from runif by box-muller transform
rnorm.vec = sqrt(-2*log(runif(n*p)))*cos(2*pi*runif(n*p))
# generate sample matrix
sample.matrix = matrix(rep(mu, n), nrow=n, byrow=T) +
matrix(rnorm.vec, nrow=n, ncol=p)%*%sigma.sqrt
return(sample.matrix)
}
ones = function(m,n){
matrix(1, nrow=m, ncol=n)
}
## function to calculate weighted projection quantile depth
EPQD1 = function(X, grid, nu=1e3){
p = ncol(X)
b = apply(X, 2, median)
X0 = X - ones(nrow(X),1) %*% b
grid0 = grid - ones(nrow(grid),1) %*% b
## get matrix of weighted PQDs for all points
npt = dim(grid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = as.matrix(rnorm(p)); u = u/sqrt(sum(u^2))
uecdf = ecdf(X0%*%u)
Fuxu.mat[,iu] = uecdf(grid0%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
return(cbind(grid,EPQD.vec))
}
wEPQD1 = function(X, grid, sig, nu=1e3){
p = ncol(X)
b = apply(X, 2, median)
X0 = X - ones(nrow(X),1) %*% b
grid0 = grid - ones(nrow(grid),1) %*% b
## get matrix of weighted PQDs for all points
npt = dim(grid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = as.matrix(rnorm(p)); u = u/sqrt(sum(u^2))
I.minus.Pu = diag(p) - u%*%t(u)
Xuperp = X0 %*% I.minus.Pu
scaled.perp = sqrt(Xuperp^2 %*% ones(ncol(X),1))
#w = ifelse(scaled.perp>sig, 0, 1)
#w = sig*exp(-scaled.perp/sig)
w = dnorm(scaled.perp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w * (X0%*%u))
gridperp = grid0 %*% I.minus.Pu
scaled.gridperp = sqrt(gridperp^2 %*% ones(ncol(X),1))
#wu = ifelse(scaled.gridperp>sig, 0, 1)
#wu = sig*exp(-scaled.gridperp/sig)
wu = dnorm(scaled.gridperp, sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu * (grid0%*%u))
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
return(cbind(grid,EPQD.vec))
}
pcarank = function(X, ...){
X = as.matrix(X)
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1 * (1/d1[,3]-1)
princomp(Xrank, ...)
}
pcarank1D = function(X, ...){
X1 = apply(X,2,rank)
princomp(X1, ...)
}
d=EPQD1(x,x)
sd = s*(max(d[,3])-d[,3])
cov(sd)
cov(s)/cov(sd)
s11=s1/5
s12=s2
norm1 = sqrt(s11^2+s12^2)
s01 = cbind(s11/norm1, s12/norm1)
cov(s01)
var(norm1/norm)
plot(s01)
diag(c(5,1)) %*% cov(s01)
diag(c(5,1)) %*% cov(s01)/3
cov(s)
cov(s01*norm1/norm)
cov(s01*(ones(1,2)%*%norm1/norm))
cov(s01*(ones(2,1)%*%(norm1/norm)))
n = ones(2,1)%*%(norm1/norm)
head(n)
cov(s01*((norm1/norm) %*% ones(1,2)))
n = (norm1/norm) %*% ones(1,2)
head(n)
cov(s01*n)
cov(s01)
cov(s1)
cov(s)
apply(s01*n, 1, mean)
apply(s01*n, 2, mean)
apply(s01/n, 2, mean)
diag(25,1) %*% var(s01*n)
diag(25,1) %*% cov(s01*n)
cov(s01*n)
diag(c(25,1)) %*% cov(s01*n)
diag(c(25,1)) %*% cov(s01) * var(n)
head(n)
var(n[,1])
var(n)
?cov
cov(s01, norm1/norm)
cov(s01, norm/norm1)
var(s01)
var(s01*n)
head(n)
cov(s01,n)
diag(c(25,1)) %*% var(s01*n)
var(s01) * var(n)
a = matrix(rnorm(2e3), ncol=2)
b=rnorm(1e3)
cov(a,b)
cov(a*b)
cov(a)*var(b)
cov(s01*n)
cov(s01)*var(n)
cov(s01)*cov(n)
cov(a)
var(b)
b1=ones(1,2) %*% b
b1=ones(,) %*% b
b1=ones(2,1) %*% b
head(b1)
b1=t(ones(2,1) %*% b)
head(b1)
cov(a*b1)
cov(a) * cov(b1)
cov(b1)
cov(s01*n)
mean(s01[,1])
var(s01[,1])
var(s01[,1]*n[,1])
mean((s01[,1]*n[,1])^2)
var(s01[,1] * mean(n[,1]^2))
var(s01[,1]) * mean(n[,1]^2)
var(s01[,1])
mean(s01[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2)
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1])*mean(n[,1]))^2
mean(s01[,1]^2) * mean(n[,1]^2) - (mean(s01[,1]*n[,1]))^2
var(s01[,1] * n[,1])
mean(s01[,1]^2 * n[,1]^2) - (mean(s01[,1]*n[,1]))^2
mean(s01[,1]^2 * n[,1]^2)
mean(s01[,1]^2)
mean(n[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(s01[,1]^2)
mean(s01[,1]^2 * n[,1]^2) / mean(n[,1]^2)
cov(s01,n[,1])
cov(sd)
cov(s)/cov(sd)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
cov(X)
n = 1e3
set.seed(120214)
# x = rnorm(n)
# X = cbind(x, 2*x)
# X = scale(X, scale=F)
Gamma = matrix(c(1,-1,1,1), nrow=2)/sqrt(2)
sig = Gamma %*% diag(c(25,1)) %*% t(Gamma)
X = my.mvrnorm(n, mu=c(0,0), Sig=2*sig)
# x = runif(n)
# X = cbind(x, x+rnorm(n, sd=.001))
# X = scale(X, scale=F)
# PCA before contamination
(p.pure <- princomp(X)); p.pure$loadings
d1 = EPQD1(X, X)
X1 = X
for(i in 1:nrow(X1)){
X1[i,] = X1[i,]/sqrt(sum(X1[i,]^2))
}
Xrank = X1
Xrank = X1 * (max(d1[,3]) - d1[,3])
cov(Xrank)
a=rchisq(1000,1)
b=rchisq(1000,1)
cov(a/(a+b),b/(a+b))
corr(a/(a+b),b/(a+b))
cor(a/(a+b),b/(a+b))
c=rchisq(1000,1)
s=a+b+c
cor(a/s,b/s)
cor(a/s,b/s,c/s)
cov(cbind(a/s,b/s,c/s))
cor(cbind(a/s,b/s,c/s))
install.packages("fastM")
require(fastM)
TYLERshape(matrix(rnorm(100),ncol=2))
X = matrix(rnorm(1e3), ncol=2)
cov(X)
TYLERshape(X)
X[91:100,] = X[91:100,] + 50
cov(X)
TYLERshape(X)
?TYLERshape
setwd("C:/Study/My projects/Depth-scatter/Codes")
rm(list=ls());
source('misc_functions.R')
library(parallel)
library(doSNOW)
## Functions
## simulate for normal dist
FSE.norm = function(n, p, iter=1e3, ncores=detectCores()){
set.seed(12182014)
v = c(rep(0,p-1), 1)
lam = 1:p
Sigma = diag(lam)
MSE.mat = matrix(0, nrow=length(n), ncol=8)
for(i in 1:length(n)){
# function to compute stuff 1000 times for a given n
loopfun = function(j){
source('misc_functions.R')
require(fastM)
require(fda.usc)
iv = rep(0,9)
# get sample and construct sign matrix
iX = matrix(rnorm(p*n[i]), ncol=p) %*% sqrt(Sigma)
iXnorm = sqrt(iX^2 %*% rep(1,p))
iS = iX / (iXnorm %*% rep(1,p))
# PCA on original sample
iP = princomp(iX)
iv[1] = abs(sum(v * iP$loadings[,1]))
# PCA on SCM
iPsign = princomp(iS)
iv[2] = abs(sum(v * iPsign$loadings[,1]))
# PCA on Tyler's cov matrix
T = TYLERshape(iX)$Sigma
iv[3] = abs(sum(v * eigen(T)$vectors[,1]))
# PCA on DCM and depth-weighted tyler's scatter
# Tukey's depth
idep = mdepth.HS(iX,iX)$dep
#idep = EPQD(iX,iX)[,p+1]
idep = max(idep) - idep
#idep=1
iXd = iS * idep
iPdepth = princomp(iXd)
iv[4] = abs(sum(v * iPdepth$loadings[,1]))
Td = TylerSig(iX, weight=idep)
iv[5] = abs(sum(v * eigen(Td)$vectors[,1]))
# Mahalanobis depth
idep = mdepth.MhD(iX,iX)$dep
idep = max(idep) - idep
iXd = iS * idep
iPdepth = princomp(iXd)
iv[6] = abs(sum(v * iPdepth$loadings[,1]))
Td = TylerSig(iX, weight=idep)
iv[7] = abs(sum(v * eigen(Td)$vectors[,1]))
# Projection depth
idep = mdepth.RP(iX,iX)$dep
idep = max(idep) - idep
iXd = iS * idep
iPdepth = princomp(iXd)
iv[8] = abs(sum(v * iPdepth$loadings[,1]))
Td = TylerSig(iX, weight=idep)
iv[9] = abs(sum(v * eigen(Td)$vectors[,1]))
iv
}
# parallel code: compute MSE elements iter times
cl = makeCluster(ncores)
registerDoSNOW(cl)
system.time(eff.v <- foreach(j=1:iter) %dopar% loopfun(j))
stopCluster(cl)
# get MSE and return
eff.v = matrix(unlist(eff.v), ncol=9, byrow=T)
(MSE.vec = apply(eff.v, 2, function(x) mean(acos(x)^2)))
MSE.mat[i,] = MSE.vec[1]/MSE.vec[-1]
}
MSE.mat
}
## simulate for t-distn
FSE.t = function(n, p, df, iter=1e3, ncores=detectCores()){
set.seed(12182014)
v = c(rep(0,p-1), 1)
lam = 1:p
Sigma = diag(lam)
MSE.mat = matrix(0, nrow=length(n), ncol=8)
for(i in 1:length(n)){
# function to compute stuff 1000 times for a given n
loopfun = function(j){
source('misc_functions.R')
require(fastM)
require(fda.usc)
require(mvtnorm)
iv = rep(0,9)
# get sample and construct sign matrix
iX = rmvt(n[i], sigma=Sigma, df=df)
iXnorm = sqrt(iX^2 %*% rep(1,p))
iS = iX / (iXnorm %*% rep(1,p))
# PCA on original sample
iP = princomp(iX)
iv[1] = abs(sum(v * iP$loadings[,1]))
# PCA on SCM
iPsign = princomp(iS)
iv[2] = abs(sum(v * iPsign$loadings[,1]))
# PCA on Tyler's cov matrix
T = TYLERshape(iX)$Sigma
iv[3] = abs(sum(v * eigen(T)$vectors[,1]))
# PCA on DCM and depth-weighted tyler's scatter
# Tukey's depth
idep = mdepth.HS(iX,iX)$dep
#idep = EPQD(iX,iX)[,p+1]
idep = max(idep) - idep
iXd = iS * idep
iPdepth = princomp(iXd)
iv[4] = abs(sum(v * iPdepth$loadings[,1]))
Td = TylerSig(iX, weight=idep)
iv[5] = abs(sum(v * eigen(Td)$vectors[,1]))
# Mahalanobis depth
idep = mdepth.MhD(iX,iX)$dep
idep = max(idep) - idep
iXd = iS * idep
iPdepth = princomp(iXd)
iv[6] = abs(sum(v * iPdepth$loadings[,1]))
Td = TylerSig(iX, weight=idep)
iv[7] = abs(sum(v * eigen(Td)$vectors[,1]))
# Projection depth
idep = mdepth.RP(iX,iX)$dep
idep = max(idep) - idep
iXd = iS * idep
iPdepth = princomp(iXd)
iv[8] = abs(sum(v * iPdepth$loadings[,1]))
Td = TylerSig(iX, weight=idep)
iv[9] = abs(sum(v * eigen(Td)$vectors[,1]))
iv
}
# parallel code: compute MSE elements iter times
cl = makeCluster(ncores)
registerDoSNOW(cl)
system.time(eff.v <- foreach(j=1:iter) %dopar% loopfun(j))
stopCluster(cl)
# get MSE and return
eff.v = matrix(unlist(eff.v), ncol=9, byrow=T)
(MSE.vec = apply(eff.v, 2, function(x) mean(acos(x)^2)))
MSE.mat[i,] = MSE.vec[1]/MSE.vec[-1]
}
MSE.mat
}
# For p=3
n.vec = c(20,50,100,300,500)
system.time(norm.table <- FSE.norm(n.vec, 3, 1e3, ncores=8))
n.vec = c(20,50,100,300,500)
system.time(norm.table <- FSE.norm(n.vec, 3, 1e3, ncores=8))
system.time(t5.table <- FSE.t(n.vec, 3, df=5, 1e3, ncores=8))
system.time(t6.table <- FSE.t(n.vec, 3, df=6, 1e3, ncores=8))
system.time(t10.table <- FSE.t(n.vec, 3, df=10, 1e3, ncores=8))
system.time(t15.table <- FSE.t(n.vec, 3, df=15, 1e3, ncores=8))
system.time(t25.table <- FSE.t(n.vec, 3, df=25, 1e3, ncores=8))
t10.table
t15.table
t5.table
system.time(t25.table <- FSE.t(n.vec, 3, df=25, 1e3, ncores=6))
table3 = rbind(t5.table, rep(0,8),
t6.table, rep(0,8),
t10.table, rep(0,8),
t15.table, rep(0,8),
t25.table, rep(0,8),
norm.table)
table3 = table3[,c(1,2,3,5,7,4,6,8)]
write.csv(format(round(table3, 2), nsmall=2), "table3.txt")
norm.table
n.vec = c(20,50,100,300,500)
system.time(norm.table <- FSE.norm(n.vec, 5, 1e3, ncores=8))
system.time(t5.table <- FSE.t(n.vec, 5, df=5, 1e3, ncores=8))
system.time(t6.table <- FSE.t(n.vec, 5, df=6, 1e3, ncores=8))
system.time(t10.table <- FSE.t(n.vec, 5, df=10, 1e3, ncores=8))
system.time(t15.table <- FSE.t(n.vec, 5, df=15, 1e3, ncores=8))
system.time(t25.table <- FSE.t(n.vec, 5, df=25, 1e3, ncores=6))
table5 = rbind(t5.table, rep(0,8),
t6.table, rep(0,8),
t10.table, rep(0,8),
t15.table, rep(0,8),
t25.table, rep(0,8),
norm.table)
table5 = table5[,c(1,2,3,5,7,4,6,8)]
write.csv(format(round(table5, 2), nsmall=2), "table5.txt")
t5.table
norm.table
t6.table
t25.table
table5
system.time(t10.table <- FSE.t(n.vec, 5, df=10, 1e3, ncores=8))
system.time(t15.table <- FSE.t(n.vec, 5, df=15, 1e3, ncores=8))
n.vec = c(20,50,100,300,500)
system.time(norm.table <- FSE.norm(n.vec, 6, 1e3, ncores=8))
system.time(t5.table <- FSE.t(n.vec, 6, df=5, 1e3, ncores=8))
n.vec = c(20,50,100,300,500)
system.time(norm.table <- FSE.norm(n.vec, 4, 1e3, ncores=8))
n.vec = c(20,50,100,300,500)
system.time(norm.table <- FSE.norm(n.vec, 4, 1e3, ncores=6))
system.time(t5.table <- FSE.t(n.vec, 4, df=5, 1e3, ncores=6))
system.time(t6.table <- FSE.t(n.vec, 4, df=6, 1e3, ncores=6))
system.time(t10.table <- FSE.t(n.vec, 4, df=10, 1e3, ncores=6))
system.time(t15.table <- FSE.t(n.vec, 4, df=15, 1e3, ncores=6))
system.time(t25.table <- FSE.t(n.vec, 4, df=25, 1e3, ncores=6))
table4 = rbind(t5.table, rep(0,8),
t6.table, rep(0,8),
t10.table, rep(0,8),
t15.table, rep(0,8),
t25.table, rep(0,8),
norm.table)
table4 = table4[,c(1,2,3,5,7,4,6,8)]
write.csv(format(round(table4, 2), nsmall=2), "table4.txt")
